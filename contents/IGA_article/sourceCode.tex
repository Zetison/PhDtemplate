\section{Source code}
The complete source code is far to comprehensive to be included in this thesis. However, we shall present the implementation of the NURBS routine in some detail as this is a fundamental function of the analysis. In addition we add the routine which create global matrices. We shall here not go into details. The source code, alongside instruction of how to use, may be given on request.

\subsection{B-spline implementation}
When we want to evaluate a B-spline at a fixed $\xi$ it is important to note that it is very redundant to evaluate all $n$ basis function. This is due to the small support of each function. In fact, it turns out that only (at most) $p+1$ basis functions are non-zero at $\xi$. It is then important to only use these function to have an efficient code. One typically implements a function which finds the knot span corresponding to a given $\xi$. Due to the ordering of the knot vector, we may use a binary search algorithm for finding this span. The span will be defined by the index $i$ corresponding to the last basis function which is non-zero at $\xi$. The following listing represents the algorithm called \mcode{findKnotSpan} and is listed in \Cref{Listings:findKnotSpan}.

As an example, if $p=2$ and $n=8$ and we want to evaluate a B-spline with the knot vector $\Xi = \{0, 0, 0, 0.1, 0.5, 0.5, 0.8, 0.9, 1, 1, 1\}$, we get the index $i=3$ if $\xi = 0.09$, $i=6$ if $\xi=0.5$ and $i=n=8$ if $\xi=0.9$ or $\xi = 1$.

We are now ready to implement a program which evaluates B-splines using the previous routine. When the recursion formula is used to evaluate the $p+1$ functions which are non-zero at $\xi$, the function $N_{i,0}$ is the only function of order zero which is non-zero at $\xi$. Everything is thus build from this function, such that we get the graph in \Cref{Fig2:BsplinesEvalGraph}.
\tikzsetnextfilename{BsplinesEvalGraph}  
\begin{figure}
	\centering
	\ifplotData
	\begin{tikzpicture}[>=triangle 60]
	  \matrix[matrix of math nodes,column sep={70pt,between origins},row
	    sep={40pt,between origins},nodes={asymmetrical rectangle}] (s)
	  {
	    	 |[name=aa]| N_{i,0} 		& |[name=ba]| N_{i-1,1} & |[name=ca]| N_{i-2,2} &  |[name=da]| \cdots 	&  |[name=ea]| \textcolor{myRed}{N_{i-p+1,p-1}} 	&  |[name=fa]| N_{i-p,p}  	\\	
	    	 					 		& |[name=bb]| N_{i,1}   & |[name=cb]| N_{i-1,2} &  |[name=db]| \cdots 	&  |[name=eb]| \textcolor{myRed}{N_{i-p+2,p-1}} 	&  |[name=fb]| N_{i-p+1,p}  \\	
	    	 					 		& 			 		    & |[name=cc]| N_{i,2}   &  |[name=dc]| \cdots 	&  |[name=ec]| \textcolor{myRed}{N_{i-p+3,p-1}} 	&  |[name=fc]| N_{i-p+2,p}  \\	
	    	 					 		& 			 		    & 					  	&  |[name=dd]| \ddots 	&  |[name=ed]| \vdots 							&  |[name=fd]|\vdots  \\	
	    	 					 		& 						& 						&  				 		&  |[name=ee]| \textcolor{myRed}{N_{i,p-1}} 		&  |[name=fe]| N_{i-1,p}  	\\	
	    	 							& 						& 						&  					  	&  									 			&  |[name=ff]| N_{i,p}  	\\	
	  };
	  \draw[->] (aa) edge (ba)
	  			(ba) edge (ca)
	  			(ca) edge (da)
	  			(da) edge (ea)
	  			(ea) edge (fa)
	  			
	  			(bb) edge (cb)
	  			(cb) edge (db)
	  			(db) edge (eb)
	  			(eb) edge (fb)
	  			
	  			(cc) edge (dc)
	  			(dc) edge (ec)
	  			(ec) edge (fc)
	  			
	  			(ee) edge (fe)
	  			
	  			(aa) edge (bb)
	  			(bb) edge (cc)
	  			(cc) edge (dd)
	  			(dd) edge (ee)
	  			(ee) edge (ff)
	  			
	  			(ba) edge (cb)
	  			(cb) edge (dc)
	  			
	  			(ca) edge (db)
	  			(db) edge (ec)
	  			
	  			(da) edge (eb)
	  			(eb) edge (fb)
	  			
	  			(ea) edge (fb);
	\end{tikzpicture}
	\fi
	\caption[B-splines evaluation graph]{B-splines evaluation graph when the $p+1$ non-zero basis functions are to be evaluated at a given $\xi$. The values colored \textcolor{myRed}{red} is used to calculate the nonzero derivatives at the same $\xi$.}
	\label{Fig2:BsplinesEvalGraph}
\end{figure}

It is then clear that we need two loops. The outer loop should iterate over the columns of this graph and the inner loop should iterate over the rows. The output of the function \mcode{Bspline_basis} is simply an array \mcode{N} which contains the $p+1$ functions which are evaluated at $\xi$. To save memory one should also store the intermediate values $N_{i-j+k, j-1}$ in this same array. Thus, we need to store \mcode{N(k-1)} to compute \mcode{N(k)} (which we store in the variable \mcode{saved}). Here, $j$ is the loop index of the outer loop, while $k$ is the loop index of the inner loop. The first iteration (when $p=0$) should be done separate.

We will finally need to compute the corresponding derivatives. Once again, only $p+1$ derivatives will be nonzero at $\xi$. Let \mcode{N_tilde} be an array containing the \textcolor{myRed}{red} values in the previous graph. The full function is found in \Cref{Listings:Bspline_basisDers}.

\subsection{NURBS implementation}
We may now insert all of this into a routine which computes the nonzero NURBS basis functions at a given point $(\xi,\eta,\zeta)$ and the corresponding nonzero derivatives. This function is called \mcode{NURBS3DBasisDers}. After finding the nonzero B-spline functions and their corresponding derivatives as discussed above, it continues by first finding the function $W$ and its corresponding derivatives. 

Note the use of the index \mcode{A} which is convenient when weights is located in an long array (which is the format we shall use when doing the IGA analysis). Finally, the function can now compute the NURBS basis alongside the corresponding derivatives.

Note the use of the intermediate variables \mcode{fac} and \mcode{NML} which is used to avoid redundant computations. The index \mcode{counter} loops over the $n_{\mathrm{en}}=(p+1)\cdot(q+1)\cdot(r+1)$ nonzero functions. The full function is found in \Cref{Listings:NURBS3DBasis}.

\subsection{Building global matrices}
The function \mcode{buildGlobalMatrices} builds any fluid or solid matrix used in this thesis. When dynamics is considered, the mass matrix will also be computed. Finally, if any bodyforces are applied, a corresponding loading vector will be constructed. As an example of use, consider any analysis concerning finding eigenvalues for elasticity problems. Then we use the function as follows.
\begin{lstlisting}
options = {'operator', 'linearElasticity',...
           'fieldDimension', 3,...
           'buildMassMatrix', 1};
[K, M, ~] = buildGlobalMatrices(varCol, options);
\end{lstlisting}
The partial differential equation resulting in the global matrix is the linear elasticity equation. Hence, we set \mcode{'operator'} to be \mcode{'linearElasticity'}. If the Helmholtz equation was to be solved, the \mcode{'operator'} is set to be \mcode{'Laplace'}. The option \mcode{'fieldDimension'} is only added for generality if other operators where to be implemented. Indeed, the solution for the linear elasticity operator is always vector valued (in 2D/3D), while the solution for the Laplace operator is scalar valued. Finally, we ask the function to build the mass matrix, as eigenvalues concerns with dynamics. The struct \mcode{varCol} simply collects all variables associated with the NURBS mesh. The full function is listed in \Cref{Listings:buildGlobal}
\raggedbottom
\lstinputlisting[caption = {\mcode{findKnotSpan.m}}, label = {Listings:findKnotSpan}]{../../data/NURBS/findKnotSpan.m}
\newpage
\lstinputlisting[caption = {\mcode{Bspline_basisDers.m}}, label = {Listings:Bspline_basisDers}]{../../data/NURBS/Bspline_basisDers.m}
\lstinputlisting[caption = {\mcode{NURBS3DBasis.m}}, label = {Listings:NURBS3DBasis}]{../../data/NURBS/NURBS3DBasis.m}
\lstinputlisting[caption = {\mcode{buildGlobalMatrices.m}}, label = {Listings:buildGlobal}]{../../data/IGAfunctions/buildGlobalMatrices.m}